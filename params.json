{"name":"Ngforce","tagline":"Force.com Angular.js framework. A better description forthwith.","body":"ngForce\r\n=======\r\n\r\n#Force.com Angular.js framework.\r\n\r\nngForce is a set of Angular.js modules that facilitate quick and sustainable Angular.js application development on the Force.com Platform. With the Angular.js modules are a set of Apex classes facilitating Visualforce Remoting. \r\n\r\n##Architectural Overview.\r\nngForce is composed of a number of independent modules that are normally comiled/minified into a single .min.js file for use. However, advanced developers can adopt singular modules from the jsSrc directory, so long as the underlying requirements for ngForce are met:\r\n\r\n1. Lo-Dash.js (or Underscore, but Lo-Dash is significantly faster)\r\n2. safeApply.js - An Angular module in it's own right, this module provides a fire and forget method of syncing external data retreival with the Angular Run loop.\r\n3. The sfr* services all require Restangular.js, an Angular.js module for better integration with mostly restful apis.\r\n\r\n#Services Overview.\r\n## /jsSrc/ngForce-visualForceRemoting.js\r\nThis service provides methods for interacting with the force.com platform without burning API calls. It does this by providing both a generic Angular-ized wrapper for *Any visualforce remoting annotated method* in your org, as well as a set of pre-wired convienence methods from the acompanying ngForceController.cls. These largely handle CRUD, Bulk Create and Update as well as manipulation of fieldsets. \r\n### Methods of Note:\r\nvfr.send() - Send gives you the ability to on-demand generate a function that make a JSRemoting call to any @remoteAction annotated method in your org. This method accepts a fully qualified && namespaced method name specifying the remoteAction method to invoke as well as an Options hash and a boolean parameter determining if the remoteAction method is allowed to return a null response object. (for instance, delete.) *This method returns a function that, when invoked, makes a promised based visualforce remoting call* Using .send() you can:\r\n\r\n```javascript\r\n\tvar makeChatterPost = vfr.send('Example.Controller.Method', options, false); \r\n```\r\n\r\nonce in your service, controller or app definition. Then you can call the method \r\n\r\n```javascript \r\nmakeChatterPost(\"foo bar baz!\");\r\n```\r\n\r\nto trigger the VisualForce Remoting call. \r\nThere are a number of convience methods pre-wired into the vfr module such as: \r\n\r\n+ bulkCreate\r\n+ bulkUpdate\r\n+ create\r\n+ clone\r\n+ del\r\n+ describe\r\n+ describeFieldSet\r\n+ describePicklistValues\r\n+ getObjectType\r\n+ getQueryResultsAsSelect2Data\r\n+ query\r\n+ queryFromFieldset\r\n+ retrieve\r\n+ search\r\n+ soqlFromFieldSet\r\n+ update\r\n+ upsert\r\n\r\n**Please note, This is a provider and as such, you can override the default \"standardOptions\" used by .send() and consequently by the convience methods in your app.setup method.**\r\n\r\n## /jsSrc/ngForce-sfTemplate.js\r\nThis service provides methods for optimizing and \"pre-building\" Angular views from Visualforce .pages in your org. Salesforce, (as of Spring 14) still injects a number of javascript tags into the .HTML that the Visualforce engine generates. Some of these .js files are not well optimized for compositing complex views from partial templates. While loading any given single partial has a negligable impact on application speed from these scripts, compositing a page out of 15 partials *does*. This service, in conjunction with the AngularTemplateCache service, provides a way to pre-fetch the view, strip the extra .js include tags and push the HTML into the $TemplateCache. There is a noticable improvement in application load times using this. \r\n* This Method is also a provider, and allows you to reset the standard regex blacklist in the app.setup method. *\r\n###Methods of Note:\r\nfromVf() - This method requests the template from Salesforce and utilizes the preset blacklist regex and strips offending js include statements from the fetched templates before inserting the template into the cache.\r\n\r\n## /jsSrc/ngForce-sfrQuery\r\nThis service is *the* service by which one queries records in Salesforce via the *rest* api. It is entirely promise based and will as soon as the request has been *sent* to Salesforce. \r\n\r\n###Methods of Note:\r\nQuery() - the query method accepts a string representation of a *soql* query. This query is handed - as is - to Salesforce only manipulating the string to ensure url-encodedness. Depending on the Query itself, the result will usually be an object of objects representing the resulting rows from Salesforce. Each of the rows returned is, itself a fully activated objects with the ability to call Update() etc.\r\n\r\nQueryAll() - This method is a double edged sword. If you need to have more than 2k records returned, this is the easiest method to do so. On the other hand, without an intentional Upper boundry in the query string itself, you can easily pull down 28k records. This will run your user's box out of memory, freeze their browser and in all likelyhood run you out of API calls if multiple people are using the service. *use wisely*\r\n\r\n## /jsSrc/ngForce-sfrBackend\r\nThis service facilitates testing by providing custom expectations, mocks and testing utilities. \r\n\r\n## /jsSrc/ngForce-sfrAnalytics.js\r\nThis service provides access to the Analytics Rest Api. \r\n\r\n### Feel free to submit pull requests with more documentation on this one.\r\n\r\n## /jsSrc/ngForce-sfr.js\r\nThis is the main *rest* api service. It provides four main methods:\r\n\r\n1. Model: this method returns a restangular object configured\r\n   for crud operations via the standard .post .get etc. methods \r\n   of restanglar. \r\n2. Insert: A convience method, for ... inserting records.\r\n3. Update: A convience method, for ... updating records.\r\n4. Delete: a convience method, for ... deleting records.\r\n\r\nWhat's important to know about the SFR service is that your queried object results return as a collection of SFR service enabled objects. Given a result set, each record has, for instance, an update() method.\r\n\r\n## /jsSrc/ngForce-remoteObjects.js\r\nThis service exposes a factory for building Remote Object methods. This is the newest service and as such has had the least amount of real-world testing. \r\n\r\n## /jsSrc/ngForce-encodeUriQuery.js\r\nThis service is used internally by the sfrBackground service to enable better testing.\r\n\r\nUsage\r\n======\r\n\r\nDuring the creation of your application module, inject the ngForce dependcy thusly:\r\n\r\n```javascript\r\nvar app = angular.module('myAwesomeAngularOnSalesforceApp', ['ngForce']);\r\n```\r\n\r\nOnce your app Module has been defined, you can include the service ngForce provides, 'vfr' in any of your controllers by adding it to the dependency injection list like this:\r\n\r\n```javascript\r\napp.controller('oppBoxCtrl', function($scope, $dialog, vfr)\r\n```\r\n\r\nThereafter in the controller you can utilize the ngForce services much like the $http, or $q services in Angular.\r\nvfr, sfr, sfrquery and all the others return promises, and therefore your services can have a clean(er), less call-back-hell flow to them. \r\n\r\nWhy is this important?\r\n======================\r\nThe Deferred / Promise pattern in Angular is a simplified version of the Q library by Kris Kowal (https://github.com/kriskowal/q) It provides a deferred object prototype with, as of Angular.js 1.1.5, just two methods, resolve and reject; and a singular property: promise. \r\nThe promise object held by the deferred object's promise property has a single method, .then() which is used to complete promises. \r\nFinally, Angular provides the $q service, which provides the constructor for building deferred objects, as well as an additional two methods, .all() and .when() \r\n\r\nSemantically, these are combined with the logic that you Defer some *work* with the *promise* to complete it, and *then* once it's complete, you act on it.\r\n\r\nSay more, How do I do that?\r\n\r\n```javascript\r\nvar pOppQuery = vfr.query(\"SELECT Id, Name, Account.Name, LeadSource, Probability, CloseDate, StageName, Amount FROM Opportunity ORDER BY CloseDate DESC\");\r\npOppQuery.then(function(d) {\r\n\t$scope.opportunities = d.records;\r\n});\r\n```\r\n\r\nIn our example above, we're calling the vfr service to make a SOQL query. This is our act of *deferring* some work -- querying Salesforce --. Vfr returns a *promise* to complete that work, which we assign to the variable pOppQuery. We call the .then() method to do some work when our promised work has been completed. \r\n\r\nNow, if that was the extent of what you could do with Deferred / Promises it'd be a nice improvement over callback hell. However, the fun doesn't end there. If your .then() method returns a promise, you can create chains promise execution -- enforcing order execution amidst asynchronous work. Here's what that looks like:\r\n\r\n```javascript\r\nvfr.query(\"SELECT Id, Active__c, Site, Type, Industry, Name, AccountNumber, NumberOfEmployees FROM Account\")\r\n\t\t.then(function(accounts){\r\n\t\t\t// we can manipulate the results of this first query, even assign scope variables with it\r\n\t\t\t$scope.accounts = accounts.records;\r\n\t\t\tvar accountIds = _.pluck(accounts.records, 'Id');\r\n\t\t\taccountIds = _.map(accountIds, function(id){ return \"'\" + id + \"'\";}).join(\", \");\r\n\t\t\t// but we must!!! return a promise, like a new ngForce method call\r\n\t\t\treturn vfr.query(\"SELECT Id, Name FROM Opportunity WHERE AccountId in (\" + accountIds + \")\");\r\n\t\t}).then(function(Opps){\r\n\t\t\t$scope.opps = Opps.records;\r\n\t\t\toppIds = _.pluck(Opps.records, \"Id\"); //shoutout to underscorejs.org!\r\n\t\t\toppIds = _.map(oppIds, function(id){ return \"'\" + id + \"'\";}).join(\", \");\r\n\t\t\treturn vfr.query(\"SELECT Id, PricebookEntry.Name, Quantity, UnitPrice FROM OpportunityLineItem WHERE OpportunityId in (\" + oppIds + \")\");\r\n\t\t}).then(function(products){\r\n\t\t\t$scope.products = products.records;\r\n\t\t\treturn products;\r\n\t\t},\r\n\t\t// This last link in the chain is our error reporting link.\r\n\t\t// If / When any of the above promises is rejected, or fails to resolve\r\n\t\t// this method runs, and in our case logs the error.\r\n\t\tfunction(error){\r\n\t\t\tlog(error);\r\n\t\t});\r\n```\r\n\r\nThis pattern is extremely useful when you're creating, for instance, an object with several child objects. In the first promise you create the parent object, and in the following promise you create the first child object -- in this second promise you'll have access to the Id of the created object, etc. \r\n\r\nFinally, at the very end of the chain, you can append an error handling function. If any of the promises are rejected the following promises will also be rejected passing the error message on to the error function.\r\n\r\nAddtionally, the $q service provides the .all() method. If you're familiar with the jQuery Deferred / Promise interface the all() method is functionally identical to the jquery $.when() method. In Angular, you utilize it this way:\r\n\r\n```javascript\r\nvar pQuery1 = vfr.query(\"Select Id from Account\");\r\nvar pQuery2 = vfr.query(\"Select Id from Contact\");\r\n\r\n$q.all(pQuery1, pQuery2).then(function{\r\n\t// Both of these promises are guaranteed to be completed successfully.\r\n});\r\n``` \r\n\r\nUsing the vfr helper methods\r\n========================\r\n\r\nvfr provides some helper methods that are intended to make the developers life simpler. Most of these are self explanitory but a couple of them are a bit more esoteric. \r\n\r\nPerhaps the most confusing is the bulkCreate method. You can invoke the bulk create method thusly:\r\n```javascript\r\nvar pBulkCreateCall = vfr.bulkCreate('objectName__c', dataRows);\r\npBulkCreateCall.then(function(results){\r\n\t//do something awesome with results\r\n});\r\n\r\n// dataRows is a numerically key'd object of objects. like this:\r\n{\r\n\t\"0\":{\"propA\":3,\"End_date__c\":\"2013-08-21T11:29:27.365Z\"},\r\n\t\"1\":{\"propA\":3,\"End_date__c\":\"2013-08-21T11:29:27.365Z\"},\r\n\t\"2\":{\"propA\":3,\"End_date__c\":\"2013-08-21T11:29:27.365Z\"},\r\n\t\"3\":{\"propA\":3,\"End_date__c\":\"2013-08-21T11:29:27.365Z\"},\r\n\t\"4\":{\"propA\":3,\"End_date__c\":\"2013-08-21T11:29:27.365Z\"},\r\n\t\"5\":{\"propA\":3,\"End_date__c\":\"2013-08-21T11:29:27.365Z\"},\r\n\t\"6\":{\"propA\":3,\"End_date__c\":\"2013-08-21T11:29:27.365Z\"},\r\n\t\"7\":{\"propA\":3,\"End_date__c\":\"2013-08-21T11:29:27.365Z\"},\r\n\t\"8\":{\"propA\":3,\"End_date__c\":\"2013-08-21T11:29:27.365Z\"},\r\n\t\"9\":{\"propA\":3,\"End_date__c\":\"2013-08-21T11:29:27.365Z\"},\r\n\t\"10\":{\"propA\":3,\"End_date__c\":\"2013-08-21T11:29:27.365Z\"},\r\n\t\"11\":{\"propA\":3,\"End_date__c\":\"2013-08-21T11:29:27.365Z\"}\r\n}\r\n\r\n// I generated that with: \r\nvar dataRows = {};\r\nfor(var i=0; i < 12; i++) {\r\n\tdataRows[i] = {'propA':3, 'End_date__c': new Date()};\r\n}\r\n\r\n// Each of the child objects should be independently insertable via the vfr.create method -- \r\n// ie: should be a json representation of the object.\r\n\r\n```\r\n","google":"UA-40872097-1","note":"Don't delete this file! It's used internally to help with page regeneration."}