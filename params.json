{"name":"Ngforce","tagline":"Force.com Angular.js framework. A better description forthwith.","body":"ngForce\r\n=======\r\n\r\nForce.com Angular.js framework.\r\n\r\nYou can find the production ready version of the library under js/ngForce/\r\nngForce depends on the safeApply module that you'll find in safeApply.js under js/ngForce\r\n\r\nNote: this is distributed unminified so that you can minify it with the rest of your Angular.js code\r\n\r\nUsage\r\n======\r\n\r\nDuring the creation of your application module, inject the ngForce dependcy thusly:\r\n```javascript\r\nvar app = angular.module('ngForceDemo', ['ui.bootstrap', 'ui', 'ngForce']);\r\n```\r\n\r\nOnce your app Module has been defined, you can include the service ngForce provides, 'vfr' in any of your controllers by adding it to the dependency injection list like this:\r\n```javascript\r\napp.controller('oppBoxCtrl', function($scope, $dialog, vfr)\r\n```\r\n\r\nNote: It probably seems strange that the module is named ngForce, but the service you're injecting is called vfr. ngForce will eventually support not only Visual Force Remoting (VFR) but also javascript ajax calls to the Rest api. The in-progress Rest service will be named, \"sfRestApi\". The module ngForce, however, provides both, hence the odd naming.\r\n\r\nThereafter in the controller you can utilize the vfr service much like the $http, or $q services in Angular.\r\nvfr returns a promise, and therefore your controllers can have a clean(er), less call-back-hell flow to them. Additionally, because promises are binary, you can group vfr callouts and act on that data only once all of the promises have resolved. For example, here's a simple SOQL query returning records via promise:\r\n\r\nWhy is this important?\r\n======================\r\nThe Deferred / Promise pattern in Angular is a simplified version of the Q library by Kris Kowal (https://github.com/kriskowal/q) It provides a deferred object prototype with, as of Angular.js 1.1.5, just two methods, resolve and reject; and a singular property: promise. \r\nThe promise object held by the deferred object's promise property has a single method, .then() which is used to complete promises. \r\nFinally, Angular provides the $q service, which provides the constructor for building deferred objects, as well as an additional two methods, .all() and .when() \r\n\r\nSemantically, these are combined with the logic that you Defer some *work* with the *promise* to complete it, and *then* once it's complete, you act on it.\r\n\r\nSay more, How do I do that?\r\n\r\n```javascript\r\nvar pOppQuery = vfr.query(\"SELECT Id, Name, Account.Name, LeadSource, Probability, CloseDate, StageName, Amount FROM Opportunity ORDER BY CloseDate DESC\");\r\npOppQuery.then(function(d) {\r\n\t$scope.opportunities = d.records;\r\n});\r\n```\r\n\r\nIn our example above, we're calling the vfr service to make a SOQL query. This is our act of *deferring* some work -- querying Salesforce --. Vfr returns a *promise* to complete that work, which we assign to the variable pOppQuery. We call the .then() method to do some work when our promised work has been completed. \r\n\r\nNow, if that was the extent of what you could do with Deferred / Promises it'd be a nice improvement over callback hell. However, the fun doesn't end there. If your .then() method returns a promise, you can create chains promise execution -- enforcing order execution amidst asynchronous work. Here's what that looks like:\r\n\r\n```javascript\r\nvfr.query(\"SELECT Id, Active__c, Site, Type, Industry, Name, AccountNumber, NumberOfEmployees FROM Account\")\r\n\t\t.then(function(accounts){\r\n\t\t\t// we can manipulate the results of this first query, even assign scope variables with it\r\n\t\t\t$scope.accounts = accounts.records;\r\n\t\t\tvar accountIds = _.pluck(accounts.records, 'Id');\r\n\t\t\taccountIds = _.map(accountIds, function(id){ return \"'\" + id + \"'\";}).join(\", \");\r\n\t\t\t// but we must!!! return a promise, like a new ngForce method call\r\n\t\t\treturn vfr.query(\"SELECT Id, Name FROM Opportunity WHERE AccountId in (\" + accountIds + \")\");\r\n\t\t}).then(function(Opps){\r\n\t\t\t$scope.opps = Opps.records;\r\n\t\t\toppIds = _.pluck(Opps.records, \"Id\"); //shoutout to underscorejs.org!\r\n\t\t\toppIds = _.map(oppIds, function(id){ return \"'\" + id + \"'\";}).join(\", \");\r\n\t\t\treturn vfr.query(\"SELECT Id, PricebookEntry.Name, Quantity, UnitPrice FROM OpportunityLineItem WHERE OpportunityId in (\" + oppIds + \")\");\r\n\t\t}).then(function(products){\r\n\t\t\t$scope.products = products.records;\r\n\t\t\treturn products;\r\n\t\t},\r\n\t\t// This last link in the chain is our error reporting link.\r\n\t\t// If / When any of the above promises is rejected, or fails to resolve\r\n\t\t// this method runs, and in our case logs the error.\r\n\t\tfunction(error){\r\n\t\t\tlog(error);\r\n\t\t});\r\n```\r\n\r\nWhile the above example is contrived, this pattern is extremely useful when you're creating, for instance, an object with several child objects. In the first promise you create the parent object, and in the following promise you create the first child object -- in this second promise you'll have access to the Id of the created object, etc. \r\n\r\nFinally, at the very end of the chain, you can append an error handling function. If any of the promises are rejected the following promises will also be rejected passing the error message on to the error function.\r\n\r\nAddtionally, the $q service provides the .all() method. If you're familiar with the jQuery Deferred / Promise interface the all() method is functionally identical to the jquery $.when() method. In Angular, you utilize it this way:\r\n\r\n```javascript\r\nvar pQuery1 = vfr.query(\"Select Id from Account\");\r\nvar pQuery2 = vfr.query(\"Select Id from Contact\");\r\n\r\n$q.all(pQuery1, pQuery2).then(function{\r\n\t// Both of these promises are guaranteed to be completed successfully.\r\n});\r\n``` \r\n\r\n\r\n","google":"UA-40872097-1","note":"Don't delete this file! It's used internally to help with page regeneration."}